// LangGraph Agent State Definition
// This defines the shared state that flows through all nodes in the graph

import { MarketData, TechnicalIndicators, Strategy, TradingSignal, RiskAssessment, Trade, BacktestResult, Portfolio } from '../shared/types';

/**
 * Represents a pattern match from the vector store
 */
export interface PatternMatch {
    id: string;
    pattern: string;
    similarity: number;
    outcome: 'BULLISH' | 'BEARISH' | 'NEUTRAL';
    historicalReturn: number;
    timestamp: Date;
    context: Record<string, any>;
}

/**
 * Represents a strategy idea generated by the LLM
 */
export interface StrategyIdea {
    name: string;
    description: string;
    type: Strategy['type'];
    symbols: string[];
    timeframe: string;
    entryConditions: string[];
    exitConditions: string[];
    parameters: Record<string, number>;
    riskParameters: {
        maxPositionSize: number;
        stopLoss: number;
        takeProfit: number;
        maxLeverage: number;
    };
    confidence: number;
    reasoning: string;
}

/**
 * Market regime classification
 */
export type MarketRegime = 'TRENDING_UP' | 'TRENDING_DOWN' | 'RANGING' | 'HIGH_VOLATILITY' | 'LOW_VOLATILITY';

/**
 * The main agent state that flows through the LangGraph
 */
export interface AgentState {
    // === Cycle Metadata ===
    cycleId: string;
    cycleStartTime: Date;
    currentStep: string;

    // === Market Context ===
    symbol: string;
    timeframe: string;
    candles: MarketData[];
    indicators: TechnicalIndicators | null;
    regime: MarketRegime | null;

    // === Pattern Memory (from vector search) ===
    similarPatterns: PatternMatch[];
    patternBias: 'BULLISH' | 'BEARISH' | 'NEUTRAL' | 'MIXED' | null;
    patternAvgReturn: number;

    // === Portfolio State ===
    portfolio: Portfolio | null;

    // === Strategy Pipeline ===
    strategyIdeas: StrategyIdea[];
    backtestResults: BacktestResult[];
    selectedStrategy: Strategy | null;

    // === Execution Pipeline ===
    signal: TradingSignal | null;
    riskAssessment: RiskAssessment | null;
    executionResult: Trade | null;

    // === Reasoning & Logging ===
    thoughts: string[];
    errors: string[];

    // === Control Flow ===
    shouldExecute: boolean;
    shouldLearn: boolean;
}

/**
 * Creates an initial empty state for a new cycle
 */
export function createInitialState(symbol: string, timeframe: string): AgentState {
    return {
        cycleId: crypto.randomUUID(),
        cycleStartTime: new Date(),
        currentStep: 'INIT',

        symbol,
        timeframe,
        candles: [],
        indicators: null,
        regime: null,

        similarPatterns: [],
        patternBias: null,
        patternAvgReturn: 0,

        portfolio: null,

        strategyIdeas: [],
        backtestResults: [],
        selectedStrategy: null,

        signal: null,
        riskAssessment: null,
        executionResult: null,

        thoughts: [],
        errors: [],

        shouldExecute: false,
        shouldLearn: false,
    };
}

/**
 * Channels define how state updates are merged
 * For arrays, we typically want to append; for objects, we want to replace
 */
export const stateChannels = {
    // Replace channels (last write wins)
    cycleId: { default: () => '' },
    cycleStartTime: { default: () => new Date() },
    currentStep: { default: () => 'INIT' },
    symbol: { default: () => 'BTC' },
    timeframe: { default: () => '1h' },
    indicators: { default: () => null },
    regime: { default: () => null },
    patternBias: { default: () => null },
    patternAvgReturn: { default: () => 0 },
    portfolio: { default: () => null },
    selectedStrategy: { default: () => null },
    signal: { default: () => null },
    riskAssessment: { default: () => null },
    executionResult: { default: () => null },
    shouldExecute: { default: () => false },
    shouldLearn: { default: () => false },

    // Array channels (append)
    candles: { default: () => [] },
    similarPatterns: { default: () => [] },
    strategyIdeas: { default: () => [] },
    backtestResults: { default: () => [] },
    thoughts: { default: () => [] },
    errors: { default: () => [] },
};
