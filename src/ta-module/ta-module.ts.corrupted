import { MarketData, TechnicalIndicators } from '../shared/types';
import * as technicalIndicators from 'technicalindicators';
import logger from '../shared/logger';

export class TAModule {
  
  async analyzeMarket(symbol: string, timeframe: string, marketData: MarketData[]): Promise<TechnicalIndicators> {
    try {
      if (marketData.length < 50) {
        throw new Error('Insufficient data for technical analysis');
      }

      const closes = marketData.map(d => d.close);
      const highs = marketData.map(d => d.high);
      const lows = marketData.map(d => d.low);
      const volumes = marketData.map(d => d.volume);

      const indicators: TechnicalIndicators = {
        rsi: this.calculateRSI(closes),
        macd: this.calculateMACD(closes),
        bollinger: this.calculateBollingerBands(closes),
        sma: this.calculateSMA(closes),
        ema: this.calculateEMA(closes),
        volume: {
          ad: this.calculateAD(highs, lows, closes, volumes),
          obv: this.calculateOBV(closes, volumes)
        },
        volatility: {
          atr: this.calculateATR(highs, lows, closes),
          standardDeviation: this.calculateStandardDeviation(closes)
        }
      };

      logger.info(`Technical analysis completed for ${symbol} on ${timeframe}`);
      return indicators;

    } catch (error) {
      logger.error(`Technical analysis failed for ${symbol}:`, error);
      throw error;
    }
  }

  private calculateRSI(prices: number[], period: number = 14): number[] {
    if (!prices || prices.length < period) {
      throw new Error(`Insufficient data for RSI: ${prices?.length || 0} < ${period}`);
    }

    try {
      const result = technicalIndicators.RSI.calculate({ values: prices, period });
      
      // Validate result
      if (!result || result.length === 0) {
        throw new Error('RSI calculation returned empty result');
      }

      // Check for null/NaN values
      const hasInvalid = result.some(v => v === null || v === undefined || !Number.isFinite(v));
      if (hasInvalid) {
        throw new Error('RSI calculation returned invalid values (null/NaN/infinite)');
      }

      return result;
    } catch (error) {
      logger.error('RSI calculation failed:', error);
      throw new Error(`RSI calculation error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private calculateMACD(prices: number[], fastPeriod: number = 12, slowPeriod: number = 26, signalPeriod: number = 9) {
    if (!prices || prices.length < slowPeriod + signalPeriod) {
      throw new Error(`Insufficient data for MACD: ${prices?.length || 0} < ${slowPeriod + signalPeriod}`);
    }

    try {
      const macdData = technicalIndicators.MACD.calculate({
        values: prices,
        fastPeriod,
        slowPeriod,
        signalPeriod,
        SimpleMAOscillator: false,
        SimpleMASignal: false
      });

      if (!macdData || macdData.length === 0) {
        throw new Error('MACD calculation returned empty result');
      }

      const macdValues = macdData.map(d => d.MACD);
      const signalValues = macdData.map(d => d.signal);
      const histogramValues = macdData.map(d => d.histogram);

      // Validate results
      const hasInvalidMACD = macdValues.some(v => v === null || v === undefined || !Number.isFinite(v));
      const hasInvalidSignal = signalValues.some(v => v === null || v === undefined || !Number.isFinite(v));
      const hasInvalidHistogram = histogramValues.some(v => v === null || v === undefined || !Number.isFinite(v));

      if (hasInvalidMACD || hasInvalidSignal || hasInvalidHistogram) {
        throw new Error('MACD calculation returned invalid values (null/NaN/infinite)');
      }

      return {
        macd: macdValues,
        signal: signalValues,
        histogram: histogramValues
      };
    } catch (error) {
      logger.error('MACD calculation failed:', error);
      throw new Error(`MACD calculation error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private calculateBollingerBands(prices: number[], period: number = 20, stdDev: number = 2) {
    if (!prices || prices.length < period) {
      throw new Error(`Insufficient data for Bollinger Bands: ${prices?.length || 0} < ${period}`);
    }

    try {
      const bbData = technicalIndicators.BollingerBands.calculate({
        values: prices,
        period,
        stdDev
      });

      if (!bbData || bbData.length === 0) {
        throw new Error('Bollinger Bands calculation returned empty result');
      }

      const upperValues = bbData.map(d => d.upper);
      const middleValues = bbData.map(d => d.middle);
      const lowerValues = bbData.map(d => d.lower);

      // Validate results
      const hasInvalidUpper = upperValues.some(v => v === null || v === undefined || !Number.isFinite(v));
      const hasInvalidMiddle = middleValues.some(v => v === null || v === undefined || !Number.isFinite(v));
      const hasInvalidLower = lowerValues.some(v => v === null || v === undefined || !Number.isFinite(v));

      if (hasInvalidUpper || hasInvalidMiddle || hasInvalidLower) {
        throw new Error('Bollinger Bands calculation returned invalid values (null/NaN/infinite)');
      }

      return {
        upper: upperValues,
        middle: middleValues,
        lower: lowerValues
      };
    } catch (error) {
      logger.error('Bollinger Bands calculation failed:', error);
      throw new Error(`Bollinger Bands calculation error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private calculateSMA(prices: number[], period: number = 20): number[] {
    if (!prices || prices.length < period) {
      throw new Error(`Insufficient data for SMA: ${prices?.length || 0} < ${period}`);
    }

    try {
      const result = technicalIndicators.SMA.calculate({ values: prices, period });
      
      if (!result || result.length === 0) {
        throw new Error('SMA calculation returned empty result');
      }

      const hasInvalid = result.some(v => v === null || v === undefined || !Number.isFinite(v));
      if (hasInvalid) {
        throw new Error('SMA calculation returned invalid values (null/NaN/infinite)');
      }

      return result;
    } catch (error) {
      logger.error('SMA calculation failed:', error);
      throw new Error(`SMA calculation error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private calculateEMA(prices: number[], period: number = 20): number[] {
    if (!prices || prices.length < period) {
      throw new Error(`Insufficient data for EMA: ${prices?.length || 0} < ${period}`);
    }

    try {
      const result = technicalindicators.EMA.calculate({ values: prices, period });
      
      if (!result || result.length === 0) {
        throw new Error('EMA calculation returned empty result');
      }

      const hasInvalid = result.some(v => v === null || v === undefined || !Number.isFinite(v));
      if (hasInvalid) {
        throw new Error('EMA calculation returned invalid values (null/NaN/infinite)');
      }

      return result;
    } catch (error) {
      logger.error('EMA calculation failed:', error);
      throw new Error(`EMA calculation error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  }

  private calculateAD(highs: number[], lows: number[], closes: number[], volumes: number[]): number[] {
    try {
      // Use Accumulation/Distribution Line implementation
      const ad: number[] = [];
      let adValue = 0;
      
      for (let i = 0; i < closes.length; i++) {
        const high = highs[i];
        const low = lows[i];
        const close = closes[i];
        const volume = volumes[i];
        
        if (high === low) {
          ad.push(adValue);
          continue;
        }
        
        const moneyFlowMultiplier = ((close - low) - (high - close)) / (high - low);
        const moneyFlowVolume = moneyFlowMultiplier * volume;
        adValue += moneyFlowVolume;
        ad.push(adValue);
      }
      
      return ad;
    } catch (error) {
      logger.error('AD calculation failed:', error);
      return new Array(closes.length).fill(0);
    }
  }

  private calculateOBV(closes: number[], volumes: number[]): number[] {
    try {
      return technicalIndicators.OBV.calculate({
        close: closes,
        volume: volumes
      });
    } catch (error) {
      logger.error('OBV calculation failed:', error);
      return new Array(closes.length).fill(0);
    }
  }

  private calculateATR(highs: number[], lows: number[], closes: number[], period: number = 14): number[] {
    try {
      return technicalIndicators.ATR.calculate({
        high: highs,
        low: lows,
        close: closes,
        period
      });
    } catch (error) {
      logger.error('ATR calculation failed:', error);
      return new Array(closes.length).fill(0);
    }
  }

  private calculateStandardDeviation(prices: number[], period: number = 20): number[] {
    const stdDev: number[] = [];
    
    for (let i = 0; i < prices.length; i++) {
      if (i < period - 1) {
        stdDev.push(0);
        continue;
      }
      
      const slice = prices.slice(i - period + 1, i + 1);
      const mean = slice.reduce((sum, val) => sum + val, 0) / period;
      const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
      stdDev.push(Math.sqrt(variance));
    }
    
    return stdDev;
  }

  detectPatterns(marketData: MarketData[]): { pattern: string; confidence: number }[] {
    const patterns: { pattern: string; confidence: number }[] = [];
    
    if (marketData.length < 10) return patterns;

    const closes = marketData.map(d => d.close);
    const highs = marketData.map(d => d.high);
    const lows = marketData.map(d => d.low);

    // Detect various patterns
    patterns.push(...this.detectCandlestickPatterns(marketData));
    patterns.push(...this.detectSupportResistance(closes));
    patterns.push(...this.detectTrendLines(closes));
    patterns.push(...this.detectDivergence(closes, this.calculateRSI(closes)));

    return patterns.filter(p => p.confidence > 0.6);
  }

  private detectCandlestickPatterns(marketData: MarketData[]): { pattern: string; confidence: number }[] {
    const patterns: { pattern: string; confidence: number }[] = [];
    
    for (let i = 2; i < marketData.length; i++) {
      const current = marketData[i];
      const previous = marketData[i - 1];

      // Hammer pattern
      if (this.isHammer(current)) {
        patterns.push({ pattern: 'Hammer', confidence: 0.7 });
      }

      // Doji pattern
      if (this.isDoji(current)) {
        patterns.push({ pattern: 'Doji', confidence: 0.6 });
      }

      // Engulfing pattern
      if (this.isBullishEngulfing(previous, current)) {
        patterns.push({ pattern: 'Bullish Engulfing', confidence: 0.8 });
      } else if (this.isBearishEngulfing(previous, current)) {
        patterns.push({ pattern: 'Bearish Engulfing', confidence: 0.8 });
      }
    }

    return patterns;
  }

  private isHammer(candle: MarketData): boolean {
    const body = Math.abs(candle.close - candle.open);
    const upperShadow = candle.high - Math.max(candle.close, candle.open);
    const lowerShadow = Math.min(candle.close, candle.open) - candle.low;
    
    return body < (candle.high - candle.low) * 0.3 && 
           lowerShadow > body * 2 && 
           upperShadow < body * 0.5;
  }

  private isDoji(candle: MarketData): boolean {
    const body = Math.abs(candle.close - candle.open);
    const range = candle.high - candle.low;
    return body < range * 0.1;
  }

  private isBullishEngulfing(prev: MarketData, curr: MarketData): boolean {
    return prev.close < prev.open && // Previous is red
           curr.close > curr.open && // Current is green
           curr.open < prev.close && // Current opens below previous close
           curr.close > prev.open;   // Current closes above previous open
  }

  private isBearishEngulfing(prev: MarketData, curr: MarketData): boolean {
    return prev.close > prev.open && // Previous is green
           curr.close < curr.open && // Current is red
           curr.open > prev.close && // Current opens above previous close
           curr.close < prev.open;   // Current closes below previous open
  }

  private detectSupportResistance(closes: number[]): { pattern: string; confidence: number }[] {
    const patterns: { pattern: string; confidence: number }[] = [];
    
    // Simple support/resistance detection using price levels
    const pivots = this.findPivotPoints(closes);
    
    pivots.forEach(pivot => {
      if (pivot.type === 'support') {
        patterns.push({ pattern: `Support at ${pivot.value}`, confidence: 0.7 });
      } else {
        patterns.push({ pattern: `Resistance at ${pivot.value}`, confidence: 0.7 });
      }
    });

    return patterns;
  }

  private findPivotPoints(levels: number[]): { type: 'support' | 'resistance'; value: number }[] {
    const pivots: { type: 'support' | 'resistance'; value: number }[] = [];
    const lookback = 5;
    
    for (let i = lookback; i < levels.length - lookback; i++) {
      const current = levels[i];
      const left = levels.slice(i - lookback, i);
      const right = levels.slice(i + 1, i + lookback + 1);
      
      const isLow = current < Math.min(...left) && current < Math.min(...right);
      const isHigh = current > Math.max(...left) && current > Math.max(...right);
      
      if (isLow) {
        pivots.push({ type: 'support', value: current });
      } else if (isHigh) {
        pivots.push({ type: 'resistance', value: current });
      }
    }
    
    return pivots;
  }

  private detectTrendLines(closes: number[]): { pattern: string; confidence: number }[] {
    const patterns: { pattern: string; confidence: number }[] = [];
    
    // Simple trend detection using linear regression
    const trend = this.calculateTrend(closes.slice(-20)); // Last 20 periods
    
    if (trend.slope > 0.1) {
      patterns.push({ pattern: 'Uptrend', confidence: Math.min(trend.rSquared * 0.8, 0.9) });
    } else if (trend.slope < -0.1) {
      patterns.push({ pattern: 'Downtrend', confidence: Math.min(trend.rSquared * 0.8, 0.9) });
    }

    return patterns;
  }

  private calculateTrend(values: number[]): { slope: number; rSquared: number } {
    const n = values.length;
    const x = Array.from({ length: n }, (_, i) => i);
    const sumX = x.reduce((sum, val) => sum + val, 0);
    const sumY = values.reduce((sum, val) => sum + val, 0);
    const sumXY = x.reduce((sum, val, i) => sum + val * values[i], 0);
    const sumXX = x.reduce((sum, val) => sum + val * val, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    const yMean = sumY / n;
    const ssTotal = values.reduce((sum, val) => sum + Math.pow(val - yMean, 2), 0);
    const ssResidual = values.reduce((sum, val, i) => {
      const predicted = slope * i + intercept;
      return sum + Math.pow(val - predicted, 2);
    }, 0);
    
    const rSquared = 1 - (ssResidual / ssTotal);
    
    return { slope, rSquared };
  }

  private detectDivergence(prices: number[], rsi: number[]): { pattern: string; confidence: number }[] {
    const patterns: { pattern: string; confidence: number }[] = [];
    
    if (prices.length < 20 || rsi.length < 20) return patterns;
    
    const priceTrend = this.calculateTrend(prices.slice(-10));
    const rsiTrend = this.calculateTrend(rsi.slice(-10));
    
    // Bullish divergence: price making lower lows, RSI making higher lows
    if (priceTrend.slope < -0.1 && rsiTrend.slope > 0.1) {
      patterns.push({ pattern: 'Bullish Divergence', confidence: 0.75 });
    }
    
    // Bearish divergence: price making higher highs, RSI making lower highs
    if (priceTrend.slope > 0.1 && rsiTrend.slope < -0.1) {
      patterns.push({ pattern: 'Bearish Divergence', confidence: 0.75 });
    }
    
    return patterns;
  }

  calculateVolatility(marketData: MarketData[]): number {
    if (marketData.length < 2) return 0;
    
    const returns: number[] = [];
    for (let i = 1; i < marketData.length; i++) {
      const returnVal = (marketData[i].close - marketData[i - 1].close) / marketData[i - 1].close;
      returns.push(returnVal);
    }
    
    const mean = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / returns.length;
    
    return Math.sqrt(variance) * Math.sqrt(252); // Annualized volatility
  }
}

const taModule = new TAModule();
export default taModule;