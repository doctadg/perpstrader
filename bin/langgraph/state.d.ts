import { MarketData, TechnicalIndicators, Strategy, TradingSignal, RiskAssessment, Trade, BacktestResult, Portfolio } from '../shared/types';
/**
 * Represents a pattern match from the vector store
 */
export interface PatternMatch {
    id: string;
    pattern: string;
    similarity: number;
    outcome: 'BULLISH' | 'BEARISH' | 'NEUTRAL';
    historicalReturn: number;
    timestamp: Date;
    context: Record<string, any>;
}
/**
 * Represents a strategy idea generated by the LLM
 */
export interface StrategyIdea {
    name: string;
    description: string;
    type: Strategy['type'];
    symbols: string[];
    timeframe: string;
    entryConditions: string[];
    exitConditions: string[];
    parameters: Record<string, number>;
    riskParameters: {
        maxPositionSize: number;
        stopLoss: number;
        takeProfit: number;
        maxLeverage: number;
    };
    confidence: number;
    reasoning: string;
}
/**
 * Market regime classification
 */
export type MarketRegime = 'TRENDING_UP' | 'TRENDING_DOWN' | 'RANGING' | 'HIGH_VOLATILITY' | 'LOW_VOLATILITY';
/**
 * The main agent state that flows through the LangGraph
 */
export interface AgentState {
    cycleId: string;
    cycleStartTime: Date;
    currentStep: string;
    symbol: string;
    timeframe: string;
    candles: MarketData[];
    indicators: TechnicalIndicators | null;
    regime: MarketRegime | null;
    similarPatterns: PatternMatch[];
    patternBias: 'BULLISH' | 'BEARISH' | 'NEUTRAL' | 'MIXED' | null;
    patternAvgReturn: number;
    portfolio: Portfolio | null;
    strategyIdeas: StrategyIdea[];
    backtestResults: BacktestResult[];
    selectedStrategy: Strategy | null;
    signal: TradingSignal | null;
    riskAssessment: RiskAssessment | null;
    executionResult: Trade | null;
    thoughts: string[];
    errors: string[];
    shouldExecute: boolean;
    shouldLearn: boolean;
}
/**
 * Creates an initial empty state for a new cycle
 */
export declare function createInitialState(symbol: string, timeframe: string): AgentState;
/**
 * Channels define how state updates are merged
 * For arrays, we typically want to append; for objects, we want to replace
 */
export declare const stateChannels: {
    cycleId: {
        default: () => string;
    };
    cycleStartTime: {
        default: () => Date;
    };
    currentStep: {
        default: () => string;
    };
    symbol: {
        default: () => string;
    };
    timeframe: {
        default: () => string;
    };
    indicators: {
        default: () => null;
    };
    regime: {
        default: () => null;
    };
    patternBias: {
        default: () => null;
    };
    patternAvgReturn: {
        default: () => number;
    };
    portfolio: {
        default: () => null;
    };
    selectedStrategy: {
        default: () => null;
    };
    signal: {
        default: () => null;
    };
    riskAssessment: {
        default: () => null;
    };
    executionResult: {
        default: () => null;
    };
    shouldExecute: {
        default: () => boolean;
    };
    shouldLearn: {
        default: () => boolean;
    };
    candles: {
        default: () => never[];
    };
    similarPatterns: {
        default: () => never[];
    };
    strategyIdeas: {
        default: () => never[];
    };
    backtestResults: {
        default: () => never[];
    };
    thoughts: {
        default: () => never[];
    };
    errors: {
        default: () => never[];
    };
};
//# sourceMappingURL=state.d.ts.map